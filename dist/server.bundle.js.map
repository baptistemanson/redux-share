{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///server.bundle.js","webpack:///webpack/bootstrap f06d1e006b3ba15d5e28","webpack:///./src/redux-share-server.js","webpack:///external \"body-parser\"","webpack:///external \"express\"","webpack:///external \"ws\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_2__","__WEBPACK_EXTERNAL_MODULE_3__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","bodyParser","WebSocketServer","Server","express","ReduxShareServer","server","options","wss","readyToServe","store","defaultOptions","debug","onConnection","onActionReceived","action","shouldDispatch","shouldSend","repeaterMode","assign","value","router","Router","use","urlencoded","extended","json","post","req","res","body","log","dispatch","send","JSON","stringify","success","message","end","bind","get","getState","_this","next","type","apply","result","undefined","origin","broadcastAction","_startListen","property","clients","filter","socket","arguments","map","sendToAction","tracedAction","_console","console","concat","Array","slice","on","parse","s"],"mappings":"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","file":"server.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"body-parser\"), require(\"express\"), require(\"ws\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"body-parser\", \"express\", \"ws\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReduxShareServer\"] = factory(require(\"body-parser\"), require(\"express\"), require(\"ws\"));\n\telse\n\t\troot[\"ReduxShareServer\"] = factory(root[\"body-parser\"], root[\"express\"], root[\"ws\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"body-parser\"), require(\"express\"), require(\"ws\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"body-parser\", \"express\", \"ws\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReduxShareServer\"] = factory(require(\"body-parser\"), require(\"express\"), require(\"ws\"));\n\telse\n\t\troot[\"ReduxShareServer\"] = factory(root[\"body-parser\"], root[\"express\"], root[\"ws\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar bodyParser = __webpack_require__(1);\n\tvar WebSocketServer = __webpack_require__(3).Server;\n\tvar express = __webpack_require__(2);\n\t\n\tvar ReduxShareServer = function () {\n\t  /**\n\t   * Constructor of the server\n\t   *\n\t   * @param {Object} server\n\t   * @param {Object} options\n\t   */\n\t\n\t  function ReduxShareServer(server, options) {\n\t    _classCallCheck(this, ReduxShareServer);\n\t\n\t    /**\n\t     * Websocket Server\n\t     */\n\t    this.wss = new WebSocketServer({ server: server });\n\t    this.readyToServe = false;\n\t\n\t    /**\n\t     * Redux store to link to the clients\n\t     */\n\t    this.store = null;\n\t\n\t    var defaultOptions = {\n\t      //if set to true, will output debug on the console\n\t      debug: false,\n\t      //if set, this function will be called at connection time. Returns the socket.\n\t      onConnection: null,\n\t      //if set, this function will be called before receiving each action. Allow you to modify the action.\n\t      onActionReceived: function onActionReceived(action) {\n\t        return action;\n\t      },\n\t      //if set, this function will filter all actions before dispatching. Returns bool.\n\t      shouldDispatch: function shouldDispatch() {\n\t        return true;\n\t      },\n\t      //if set, this function will filter all actions before sending. Returns bool.\n\t      shouldSend: function shouldSend() {\n\t        return true;\n\t      },\n\t      //if true dispatches all actions received to all other connected clients. Please note that the API call to state bypasses this option.\n\t      repeaterMode: false\n\t    };\n\t\n\t    this.options = Object.assign({}, defaultOptions, options);\n\t  }\n\t\n\t  /**\n\t   * Return an Express middleware\n\t   *\n\t   * @returns {*}\n\t   */\n\t\n\t\n\t  _createClass(ReduxShareServer, [{\n\t    key: 'getExpressMiddleware',\n\t    value: function getExpressMiddleware() {\n\t      var router = express.Router();\n\t\n\t      router.use(bodyParser.urlencoded({ extended: false }));\n\t      router.use(bodyParser.json());\n\t\n\t      router.post('/action', function (req, res) {\n\t        var action = req.body;\n\t        this.log('Dispatching an action to the store', action);\n\t\n\t        if (this.store) {\n\t          this.store.dispatch(action);\n\t          res.send(JSON.stringify({ success: true }));\n\t        } else {\n\t          var message = \"Not ready yet, did you attach the redux middleware and dispatch the action @@SERVER-LISTEN-START?\";\n\t          this.log(message);\n\t          res.send(JSON.stringify({ success: false, message: message }));\n\t        }\n\t        res.end();\n\t      }.bind(this));\n\t\n\t      router.get('/state', function (req, res) {\n\t        res.send(JSON.stringify(this.store.getState(), null, 4));\n\t        res.end();\n\t      }.bind(this));\n\t\n\t      return router;\n\t    }\n\t\n\t    /**\n\t     * Get the middleware for Redux\n\t     * This middleware will broadcast server actions to all clients\n\t     *  \n\t     *  \n\t             Local      WS\n\t               +        +\n\t               |        |\n\t               |        |\n\t               v        v  onActionReceived\n\t          +----+--------+----+\n\t          |                  |\n\t          |                  |\n\t          |    Middleware    |\n\t          |                  |\n\t          |                  |\n\t          +--------+---------+\n\t                   |       ShouldDispatch?\n\t          +--------v---------+\n\t          |                  |\n\t          |     Reducers     |\n\t          |      (next)      |\n\t          |                  |\n\t          +--------+---------+\n\t                   |\n\t          +--------v---------+\n\t          |                  |\n\t          |    Middleware    |\n\t          |                  |\n\t          +--------+---------+\n\t                   |       ShouldSend?\n\t                   v\n\t                   WS\n\t      *\n\t     * @returns {Function}\n\t     */\n\t\n\t  }, {\n\t    key: 'getReduxMiddleware',\n\t    value: function getReduxMiddleware() {\n\t      var _this = this;\n\t\n\t      return function (store) {\n\t        return function (next) {\n\t          return function (action) {\n\t            _this.log('Action \"' + action.type + '\" received by the server redux middleware');\n\t\n\t            if (_this.store === null) {\n\t              _this.store = store;\n\t            }\n\t\n\t            //should dispatch?\n\t            if (_this.options.shouldDispatch.apply(_this, action)) {\n\t              var result = next(action);\n\t            } else {\n\t              var result = null;\n\t            }\n\t\n\t            // If the action have been received, we don't send it back to the client\n\t            if (action.origin === undefined || action.origin === 'server') {\n\t              if (_this.options.repeaterMode) {\n\t                _this.broadcastAction(action);\n\t              }\n\t            }\n\t            if (action.type === \"@@SERVER-LISTEN-START\") _this._startListen();\n\t            return result;\n\t          };\n\t        };\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Finds a list of socket matching a property\n\t     *\n\t     * return [] if nothing found.\n\t     * @param property\n\t     * @param value.\n\t     * @returns {array}\n\t     */\n\t\n\t  }, {\n\t    key: 'findSockets',\n\t    value: function findSockets(property, value) {\n\t      return this.wss.clients.filter(function each(socket) {\n\t        return socket[property] !== undefined && socket[property] === value;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Broadcasts a message to all clients\n\t     * \n\t     * Bypasses the repeaterMode option.\n\t     * @param action\n\t     * @param senderSocket\n\t     * @returns array\n\t     */\n\t\n\t  }, {\n\t    key: 'broadcastAction',\n\t    value: function broadcastAction(action) {\n\t      var filter = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\t\n\t\n\t      this.log(\"Dispatches an action to all clients\", action);\n\t\n\t      if (typeof filter !== 'function') filter = function filter() {\n\t        return true;\n\t      };\n\t\n\t      return this.wss.clients.filter(filter).map(function each(socket) {\n\t        return this.sendToAction(action, socket);\n\t      }.bind(this));\n\t    }\n\t\n\t    /**\n\t     * Sends an action\n\t     * @param socket\n\t     * @param action\n\t     */\n\t\n\t  }, {\n\t    key: 'sendToAction',\n\t    value: function sendToAction(action, socket) {\n\t      var tracedAction = Object.assign({}, action, { origin: \"server\" });\n\t\n\t      if (this.options.shouldSend.apply(this, [tracedAction, socket])) {\n\t        this.log(\"Dispatches an action to a client\", tracedAction);\n\t        return socket.send(JSON.stringify(tracedAction));\n\t      }\n\t    }\n\t\n\t    /**\n\t    * Internal log function\n\t    *\n\t    */\n\t\n\t  }, {\n\t    key: 'log',\n\t    value: function log() {\n\t      if (this.options.debug) {\n\t        var _console;\n\t\n\t        (_console = console).log.apply(_console, [\"redux-share-server: \"].concat(Array.prototype.slice.call(arguments)));\n\t      }\n\t    }\n\t\n\t    /**\n\t    * Private method to init the store\n\t    */\n\t\n\t  }, {\n\t    key: '_startListen',\n\t    value: function _startListen() {\n\t\n\t      this.wss.on('connection', function connection(socket) {\n\t        if (typeof this.options.onConnection == 'function') {\n\t          socket = this.options.onConnection(socket) || socket;\n\t        }\n\t\n\t        socket.on('message', function incoming(message) {\n\t          this.log(\"Received from client the message \", message);\n\t\n\t          var action = JSON.parse(message);\n\t\n\t          if (typeof this.options.onActionReceived == 'function') {\n\t            action = this.options.onActionReceived.apply(this, [action, socket]);\n\t          }\n\t\n\t          this.log('Dispatching the action to the store', action);\n\t\n\t          if (this.store) {\n\t            this.store.dispatch(action);\n\t          } else {\n\t            this.log('Store not ready yet, did you forget to add the redux middleware?');\n\t          }\n\t\n\t          if (this.options.repeaterMode) {\n\t            this.broadcastAction(action, function (s) {\n\t              return s !== socket;\n\t            });\n\t          }\n\t        }.bind(this));\n\t      }.bind(this));\n\t      this.readyToServe = true;\n\t    }\n\t  }]);\n\t\n\t  return ReduxShareServer;\n\t}();\n\t\n\tmodule.exports = ReduxShareServer;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"body-parser\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"express\");\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"ws\");\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** server.bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f06d1e006b3ba15d5e28\n **/","\"use strict\";\nvar bodyParser = require('body-parser');\nvar WebSocketServer = require('ws').Server;\nvar express = require('express');\n\n\nclass ReduxShareServer {\n  /**\n   * Constructor of the server\n   *\n   * @param {Object} server\n   * @param {Object} options\n   */\n  constructor (server,\n               options) {\n    /**\n     * Websocket Server\n     */\n    this.wss = new WebSocketServer({server: server});\n    this.readyToServe = false;\n\n    /**\n     * Redux store to link to the clients\n     */\n    this.store = null;\n\n    let defaultOptions = {\n      //if set to true, will output debug on the console\n      debug:false,\n      //if set, this function will be called at connection time. Returns the socket.\n      onConnection:null,\n      //if set, this function will be called before receiving each action. Allow you to modify the action.\n      onActionReceived: action => action,\n      //if set, this function will filter all actions before dispatching. Returns bool.\n      shouldDispatch:() => true, \n      //if set, this function will filter all actions before sending. Returns bool.\n      shouldSend: () => true,\n      //if true dispatches all actions received to all other connected clients. Please note that the API call to state bypasses this option.\n      repeaterMode:false\n    };\n\n    this.options = Object.assign({},defaultOptions,options);\n  }\n\n  /**\n   * Return an Express middleware\n   *\n   * @returns {*}\n   */\n  getExpressMiddleware () {\n    var router = express.Router();\n\n    router.use(bodyParser.urlencoded({extended: false}));\n    router.use(bodyParser.json())\n\n    router.post('/action', function (req, res) {\n      let action = req.body;\n      this.log('Dispatching an action to the store', action);\n      \n      if(this.store) {\n        this.store.dispatch(action);\n        res.send(JSON.stringify({success: true}));\n      }\n      else {\n        let message = \"Not ready yet, did you attach the redux middleware and dispatch the action @@SERVER-LISTEN-START?\";\n        this.log(message);\n        res.send(JSON.stringify({ success: false, message:message }));\n      }\n      res.end();\n      \n    }.bind(this));\n\n    router.get('/state', function (req, res) {\n      res.send(JSON.stringify(this.store.getState(), null, 4));\n      res.end();\n    }.bind(this));\n\n    return router;\n  }\n\n  /**\n   * Get the middleware for Redux\n   * This middleware will broadcast server actions to all clients\n   *  \n   *  \n           Local      WS\n             +        +\n             |        |\n             |        |\n             v        v  onActionReceived\n        +----+--------+----+\n        |                  |\n        |                  |\n        |    Middleware    |\n        |                  |\n        |                  |\n        +--------+---------+\n                 |       ShouldDispatch?\n        +--------v---------+\n        |                  |\n        |     Reducers     |\n        |      (next)      |\n        |                  |\n        +--------+---------+\n                 |\n        +--------v---------+\n        |                  |\n        |    Middleware    |\n        |                  |\n        +--------+---------+\n                 |       ShouldSend?\n                 v\n                 WS\n\n   *\n   * @returns {Function}\n   */\n  getReduxMiddleware() {\n    return store => next => action => {\n      this.log('Action \"' + action.type + '\" received by the server redux middleware');\n\n      if(this.store === null) {\n        this.store = store;\n      }\n\n      //should dispatch?\n      if(this.options.shouldDispatch.apply(this,action) ) {\n        var result = next(action);\n      }\n      else {\n        var result = null;\n      }\n      \n      // If the action have been received, we don't send it back to the client\n      if (action.origin === undefined || action.origin === 'server') {\n        if (this.options.repeaterMode) {\n          this.broadcastAction(action);\n        }\n      }\n      if (action.type === \"@@SERVER-LISTEN-START\") this._startListen();\n      return result;\n    }\n  }\n\n  /**\n   * Finds a list of socket matching a property\n   *\n   * return [] if nothing found.\n   * @param property\n   * @param value.\n   * @returns {array}\n   */\n  findSockets(property,value) {\n    return this.wss.clients.filter(function each (socket) {\n      return (socket[property] !== undefined && socket[property] === value);\n    });\n  }\n\n  /**\n   * Broadcasts a message to all clients\n   * \n   * Bypasses the repeaterMode option.\n   * @param action\n   * @param senderSocket\n   * @returns array\n   */\n  broadcastAction(action,filter = null) {\n\n    this.log(\"Dispatches an action to all clients\", action);\n\n    if(typeof(filter) !== 'function') filter = () => true;\n    \n    return this.wss.clients.filter(filter).map(function each (socket) {\n      return this.sendToAction(action, socket);\n    }.bind(this));\n  }\n\n\n  /**\n   * Sends an action\n   * @param socket\n   * @param action\n   */\n  sendToAction(action,socket) {\n    let tracedAction = Object.assign({},action,{origin:\"server\" });\n    \n    if(this.options.shouldSend.apply(this, [tracedAction, socket])) {\n      this.log(\"Dispatches an action to a client\", tracedAction);\n      return socket.send(JSON.stringify(tracedAction));\n    }\n\n  }\n\n  /**\n  * Internal log function\n  *\n  */\n  log() {\n    if (this.options.debug) {\n        console.log(\"redux-share-server: \", ...arguments);\n      }\n  }\n\n  /**\n  * Private method to init the store\n  */\n  _startListen() {\n\n    this.wss.on('connection', function connection (socket) {\n      if (typeof(this.options.onConnection) == 'function') {\n        socket = this.options.onConnection(socket) || socket;\n      }\n\n      socket.on('message', function incoming (message) {\n        this.log(\"Received from client the message \",message);\n\n        let action = JSON.parse(message);\n\n        if (typeof(this.options.onActionReceived) == 'function') {\n          action = this.options.onActionReceived.apply(this, [action, socket])\n        }\n\n        this.log('Dispatching the action to the store', action);\n\n        if(this.store) {\n          this.store.dispatch(action);\n        }\n        else {\n          this.log('Store not ready yet, did you forget to add the redux middleware?')\n        }\n\n        if (this.options.repeaterMode) {\n          this.broadcastAction(action,s => s !== socket);\n        }\n      }.bind(this));\n\n    }.bind(this));\n    this.readyToServe = true;\n  }\n\n}\n\n\nmodule.exports = ReduxShareServer;\n\n\n/** WEBPACK FOOTER **\n ** ./src/redux-share-server.js\n **/","module.exports = require(\"body-parser\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"body-parser\"\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = require(\"express\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"express\"\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = require(\"ws\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"ws\"\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}